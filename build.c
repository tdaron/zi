#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define NOB_IMPLEMENTATION
#include "includes/nob.h"

#define DIST_FOLDER "dist/"
#define OBJ_FOLDER DIST_FOLDER "obj/"

typedef struct {
    char* obj_name;
    char* plugin_name;
    int plugin_name_length;
} Plugin;

typedef struct {
    Plugin* items;
    size_t count;
    size_t capacity;
} Plugins;

static Plugins plugins = { 0 };
static bool rebuild_everything = false;
static bool updated_something = false;

// --------------------------------------------------------
// Helpers
// --------------------------------------------------------


static bool includes_newer_than(const char* target)
{
    Nob_File_Paths headers = { 0 };
    bool newer = false;

    if (nob_read_entire_dir("includes", &headers)) {
        for (size_t i = 0; i < headers.count; i++) {
            char* name = nob_temp_sprintf("includes/%s", headers.items[i]);
            if (strcmp(name, "includes/generated_plugins.h") == 0) continue;
            if (nob_needs_rebuild1(target, name)) {
                newer = true;
                break;
            }
        }
    }
    nob_da_free(headers);
    return newer;
}


static const char* compile_object_async(Nob_Procs* procs, const char* src)
{
    const char* name = nob_path_name(src);
    const char* dot = strrchr(name, '.');
    size_t len = dot ? (size_t)(dot - name) : strlen(name);
    Nob_String_View base = nob_sv_from_parts(name, len);
    const char* obj = nob_temp_sprintf(OBJ_FOLDER SV_Fmt ".o", SV_Arg(base));

    if (!nob_needs_rebuild1(obj, src) && !rebuild_everything) {
        nob_log(NOB_INFO, "%s up to date", obj);
        return obj;
    }

    Nob_Cmd cmd = { 0 };
    nob_cmd_append(&cmd, "gcc", "-c");
    nob_cc_flags(&cmd);
    nob_cc_inputs(&cmd, src);
    nob_cmd_append(&cmd, "-g", "-Iincludes", "-Iconfig", "-Wno-missing-braces");
    nob_cc_output(&cmd, obj);
    nob_cmd_run(&cmd, .async = procs);
    updated_something = true;
    return obj;
}

static void link_executable(const char* out, const char* main_obj, Nob_File_Paths objs)
{
    Nob_Cmd cmd = { 0 };
    nob_cc(&cmd);
    nob_cmd_append(&cmd, main_obj, OBJ_FOLDER "clay.o");
    nob_da_append_many(&cmd, objs.items, objs.count);
    for (size_t i = 0; i < plugins.count; i++)
        nob_da_append(&cmd, plugins.items[i].obj_name);
    nob_cc_output(&cmd, out);

    updated_something = true;
    if (!nob_cmd_run(&cmd)) {
        nob_log(NOB_ERROR, "Link failed: %s", out);
        exit(1);
    }
    printf("[DONE] Linked %s\n", out);
}

static bool is_file(const char* name) { return strchr(name, '.') != NULL; }

// --------------------------------------------------------
// Plugin Compilation
// --------------------------------------------------------

static void compile_plugins_from_dir(const char* dir, Nob_Procs* procs)
{
    nob_log(NOB_INFO, "Reading plugins from %s", dir);
    Nob_File_Paths children = { 0 };
    if (!nob_read_entire_dir(dir, &children))
        return;

    for (size_t i = 0; i < children.count; i++) {
        const char* child = children.items[i];
        if (!strcmp(child, ".") || !strcmp(child, "..") || child[0] == '_')
            continue;

        const char* path = nob_temp_sprintf("%s/%s", dir, child);
        if (is_file(child)) {
            nob_log(NOB_INFO, "Compiling %s", path);
            const char* obj = compile_object_async(procs, path);
            Plugin p = {
                .obj_name = (char*)obj,
                .plugin_name = (char*)child,
                .plugin_name_length = (int)(strlen(child) - 2),
            };
            nob_da_append(&plugins, p);
        } else {
            compile_plugins_from_dir((char*)path, procs);
        }
    }
}

static void generate_plugins_header(void)
{
    FILE* f = fopen("./includes/generated_plugins.h", "w");
    fprintf(f, "// auto-generated by build.c\n");
    fprintf(f, "typedef void (*PluginInitFunction)();\n");
    fprintf(f, "#define PLUGINS_COUNT %zu\n", plugins.count);

    for (size_t i = 0; i < plugins.count; i++) {
        Plugin* p = &plugins.items[i];
        fprintf(f, "void %.*s_init();\n", p->plugin_name_length, p->plugin_name);
        fprintf(f, "void %.*s_apply();\n", p->plugin_name_length, p->plugin_name);
    }

    fprintf(f, "PluginInitFunction pluginsInitFunctions[] = {\n");
    for (size_t i = 0; i < plugins.count; i++)
        fprintf(f, "%.*s_init,\n", plugins.items[i].plugin_name_length, plugins.items[i].plugin_name);
    fprintf(f, "};\nPluginInitFunction pluginsApplyFunctions[] = {\n");
    for (size_t i = 0; i < plugins.count; i++)
        fprintf(f, "%.*s_apply,\n", plugins.items[i].plugin_name_length, plugins.items[i].plugin_name);
    fprintf(f, "};\n");
    fclose(f);
}


// --------------------------------------------------------
// Main build
// --------------------------------------------------------

int main(int argc, char** argv)
{
    NOB_GO_REBUILD_URSELF(argc, argv);
    nob_mkdir_if_not_exists(DIST_FOLDER);
    nob_mkdir_if_not_exists(OBJ_FOLDER);

    Nob_Procs procs = { 0 };
    Nob_File_Paths common_objs = { 0 };

    // clay.o build
    if (nob_needs_rebuild1(OBJ_FOLDER "clay.o", "includes/clay.h")) {
        Nob_Cmd cmd = { 0 };
        nob_cc(&cmd);
        nob_cmd_append(&cmd, "-c", "-x", "c", "-O3", "-DCLAY_IMPLEMENTATION");
        nob_cc_inputs(&cmd, "includes/clay.h");
        nob_cc_output(&cmd, OBJ_FOLDER "clay.o");
        nob_cmd_run(&cmd, .async = &procs);
        updated_something = true;
    } else {
        nob_log(NOB_INFO, OBJ_FOLDER "clay.o up to date.");
    }

    rebuild_everything = includes_newer_than(OBJ_FOLDER "main.o");

    const char* sources[] = { "src/termgfx.c", "src/buffer.c", "src/renderer.c", "src/layout.c", "src/editor.c",
        "src/utf8.c", "src/io.c", "src/vec.c" };

    for (size_t i = 0; i < NOB_ARRAY_LEN(sources); i++)
        nob_da_append(&common_objs, compile_object_async(&procs, sources[i]));

    const char* tests_obj = compile_object_async(&procs, "tests/main_tests.c");

    nob_log(NOB_INFO, "Compiling plugins...");
    compile_plugins_from_dir("plugins", &procs);
    generate_plugins_header();

    const char* main_obj = compile_object_async(&procs, "src/main.c");

    if (!nob_procs_wait(procs)) {
        nob_log(NOB_ERROR, "A compilation failed.");
        return 1;
    }

    nob_log(NOB_INFO, "Linking...");
    if (updated_something) {
        link_executable("dist/main", main_obj, common_objs);
        link_executable("dist/tests", tests_obj, common_objs);
    } else {
        nob_log(NOB_INFO, "No need to link. Nothing changed.");
    }
    nob_da_free(procs);
    nob_da_free(common_objs);
    return 0;
}
